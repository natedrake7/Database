Λαμπρόπουλος Κωνσταντίνος
Γκέργκη Δημήτρης

Η εργασία αυτή χρησιμοποιεί διάφορες μεθόδους αποθήκευσης δεδομένων ως προσομοίωση μίας βάσης δεδομένων.Αναλυτικότερα με τη χρήση της βιβλιοθήκης bf,
δημιουργούνται 3 είδη αρχείων : Απλό HeapFile,StaticHashFile,SecondaryHashFile.
Το απλό HeapFile αποτελεί τον πιο απλό τρόπο αποθήκευσης δεδομένων,όπου κάθε δεδομένο προς αποθήκευση,αποθηκεύεται στο τέλος του αρχείου.Τo HashFile χρησιμοποιώντας ένα HashFunction χωρίζει το αρχείο σε buckets και προσθέτει τα δεδομένα προς αποθήκευση στο αντίστοιχο bucket(συνήθως στα primary hash files το hash γίνεται στο primary key).Τέλος το SecondaryHashFile χρησιμοποιώντας ένα άλλο μέρος των δεδομένων προς αποθήκευση (εδώ το name από τα records) και μέσω του hash του name αποθηκεύεται στο SHT το block στο οποίο βρίσκεται το record στο HashFile και το name που έγινε hash.

Υπάρχουν αναλυτικά σχόλια για τις υλοποιήσεις στα πηγαία αρχεία.
Οι συναρτήσεις main που παραδίδονται έχουν και ένα τρόπο βαθμολόγησης ενός τυπικής εκτέλεσης για κάθε ένα από τα είδη database που ζητήθηκαν(Heap,Primary Hash,Secondary Hash).
Όσον αφορά τις συναρτήσεις για κάθε ένα από τα databases,οι συναρτήσεις Create(),Open(),Close() είναι παρόμοιες σ'όλα τα πηγαία αρχεία.

Ειδικότερα η Create() αρχικοποιεί ένα αρχείο με το ζητούμενο όνομα και περνάει τα βασικά metadata στο πρώτο block(πχ file descriptor ή αριθμός buckets).
Υπάρχει και ένα integer value τύπου type που βρίσκεται στην αρχή του block 0 ,που αν είναι 0 ειναι heap file,αν είναι 1 Primary Hash File,αν είναι 2 Secondary Hash File.
Επίσης κλείνει το αρχείο που δημιουργήθηκε αφού δεν είναι σίγουρο ότι θα χρησιμοποιηθεί.

Η open() ανοίγει το αρχείο με όνομα filename παίρνει το block 0 και ελέγχει το integer val για να δει αν ζητήθηκε να ανοιχτεί σωστό αρχείο.
Αν είναι το σωστό αρχείο περνάει στην θέση filedesc του block 0 το νέο filedescriptor που του δίνει το επίπεδο BF και επιστρέφει τα metadata του αρχείου.
Με την Open() μένει pinned το block 0 με τα metadata ,τ'οποίο θα γίνει unpin όταν πάμε να κλείσουμε το αρχείο.

H close() βρίσκει πρώτα το block0 του αρχείου που θέλουμε να κλείσουμε και το κάνει unpin και έπειτα κλείνει το αρχείο.

Υλοιποίησεις Heap File: 

1)Insert Entries:
H εισαγωγή γίνεται στο τέλος του .db αρχείου επομένως αν έχουμε παραπάνω από ένα block στο .db αρχείο ελέγχουμε αν το τελευταίο block έχει χώρο,
αν ναι ,εισάγουμε τα records στο τέλος του block αυτού,αλλιώς δημιουργούμε νέο block και εισάγουμε τα records.

2)Get All Entries:
Τα δεδομένα είναι αποθηκευμένα τυχαία,οπότε πρέπει να κάνουμε brute force αναζήτηση σ'όλο το database.Άρα παίρνουμε κάθε block,
ελέγχουμε κάθε record που έχει μέσα αν είναι αυτό που ψάχουμε,αν ναι εκτυπώνουμε το record και επιστρέφουμε τον αριθμό των blocks που
ψάξαμε (δεν υπάρχουν διπλότυπα IDs).Αλλιώς ψάχνουμε στο επόμενο block.

Υλοιποίησεις Primary Hash File: 

1)Insert Entry : 
Η εισαγωγή γίνεται στο τέλος του bucket ,στο οποίο αντιστοιχεί το record.Βρίσκουμε το bucket με την χρήση του hash function,ελέγουμε από τα 
metadata του αρχείου αν υπάρχει τουλάχιστον ένα block στο bucket (μέσω του hash array).Αν όχι ,τότε δημιουργούμε νέο block και προσθέτουμε το
record και αντιστοιχούμε το bucket αυτό (το κελί του hash array με δείκτη με τιμή bucket) στο ID του block.Αλλιώς ψάχνουμε να βρούμε το τελευταίο
block του bucket (κάθε block μέσα σ'ένα bucket δείχνει στο επόμενο block του bucket).Όταν το βρούμε ,ελέγχουμε αν έχει χώρο για να εισάγουμε το record,
αλλιώς δημιοργούμε νέο block.Αν δημιουργήσουμε νέο block πρέπει όμως να θέσουμε το προηγούμενο block του bucket να δείχνει σε αυτό.
Επομένως ψάχνουμε και βρίσκουμε το τελευταίο block του bucket και το θέτουμε να δείχνει στο νέο μας block.

2)Get All Entries :
Βρίσκουυμε το bucket στο οποίο αντιστοιχεί η τιμή του κλειδιού που μας δίνεται (μέσω του hash function) και διανύουμε το bucket μέχρι να βρούμε 
το ζητούμενο κλειδί.Όταν το βρούμε εκτυπώνουμε το Record και επιστρέφουμε τον αριθμό των blocks που ψάξαμε (μιάς και δεν υπάρχουν διπλότυπα).

Υλοιποίησεις Secondary Hash File:

1)Ο τρόπος εισαγωγής είναι παρόμοιος με του Primary Hash File,αυτό που αλλάζει είναι το κριτήριο εισαγωγής σ'ένα bucket και το τι εισάγουμε.
Το hashing τώρα δεν γίνεται στο κλειδί ενός record,αλλά στο όνομα του,και δεν εισάγεται όλο το record αλλά μόνο το όνομα και το block στ'οποίο 
βρίσκεται το record αυτό (στο Primary Hash File).Κατά τ'άλλα ο τρόπος εισαγωγής και λειτουργίας του bucket ως μία απλά συνδεδεμένη λίστα από blocks
παραμένει ίδια.

ΥΓ: Το όνομα και το block ID συγχωνεύονται στην struct sRecord που βρίσκεται στο sht_table.h .

2)Get All Entries :
Εδώ η αναζήτηση γίνεται βάσει το όνομα και όχι το κλειδί ενός record.Επομένως εφαρμόζουμε το hash function του SHT,βρίσκουμε το
bucket στ'οποίο αντιστοιχεί και ψάχνουμε όλα τα blocks του bucket για το όνομα αυτό.Εδώ σε αντίθεση με τις παραπάνω Get All Entries,
δεν σταματάμε στο πρώτο record που θα ταυτίζεται με το ζητούμενο,γιατί μπορεί να υπάρχουν και άλλα records με ίδιο όνομα.Επομένως ψάχνουμε
την λίστα από blocks που αντιστοιχεί στο bucket μας και επιστρέφουμε τα blocks που ψάξαμε.Συνήθως είναι πολύ λίγα μιάς και κάθε block εδώ 
χωράει 25 records σε αντίθεση με τα άλλα databases που χωράνε 6.

Compilation:
Για τις hp_main,ht_main,sht_main υπάρχει το makefile με τις εντολές make hp,make ht,make sht αντίστοιχα.Επίσης υπάρχει και makefile command
για την hash statistics με εντολή make stats,και για να τρέξετε το εκτελέσιμο είναι ./build/stats_main .

